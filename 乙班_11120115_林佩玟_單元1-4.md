11120115 林佩玟
HackMD [https://hackmd.io/@bbwkD4OjT7iRyASFw0KsJA/rJ3oR12TC](https://)
# 單元1 遞迴
## 遞迴
* 用相同的方法來解決問題(自己呼叫自己)，直到基本情況(base case)為止
* 將大問題分解為小問題解決(divide and conquer)
* 程式碼簡潔且容易理解, 但效率不一定好
* 遞迴可能導致堆疊溢出(stack overflow)，特別是遞迴深度過大時。
* 遞迴題目: 階乘Factorial, 最大公因數Greatest Common Divisor, 搜尋Search in Array, 費式數列Fibonacci series, 組合數Combinatorial numbers, 河內塔Towers of Hanoi...

## Binary search
* 在每次遞迴中，將資料分成兩半來縮小搜尋範圍。
* Base Case 可以有兩種情況：
    * 找到目標值：返回其位置或確認找到
    * 無法找到目標值：返回 -1 或其他標記表示搜尋失敗

## Finding the Kth Smallest Item in an Array
* 隨機選擇選取一個位置作為 pivot item
* 從左到右開檢查數值
    * 若數值小於 pivot，將其移到 pivot 的左邊
    * 若數值大於 pivot，將其移到 pivot 的右邊
    * 過程中不斷移動箭頭，並在需要時交換元素位置
* 檢查 pivot 位置
    * 若 pivot 位於第 K 個位置，表示第 K 小的項目 -> 返回
    * 若 pivot 的位置在 K 之後，左邊陣列中繼續尋找
    * 若 pivot 的位置在 K 之前，右邊陣列中尋找尋找

## Towers of Hanoi
* 將一疊圓盤從一根柱子移動到另一根柱子
* 一次只能移動一個圓盤 且 大圓盤不能放在小圓盤上
* Base Case：
    * 若只有一個圓盤，將圓盤從柱子 A 移到柱子 C。
* 遞迴步驟：
    * 將前 n-1 個圓盤從柱子 A 移到柱子 B
    * 將第 n 個圓盤（最大的圓盤）從柱子 A 移到柱子 C
    * 將 n-1 個圓盤從柱子 B 移到柱子 C

## Fibonacci series
* 數學數列 每個數字是前兩個數字的和 0, 1, 1, 2, 3, 5, 8, 13,...
* Base Case：
    * 當 n 等於 0 或 1 時，返回 n
* 遞迴步驟： 
    * 當 n>1 時，呼叫自己來計算 F(n−1) 和 F(n−2)
* 舉例 : F(3) 會呼叫自己的函數 F(2) 和 F(1)，直到 F(0) or F(1) 才會回傳

## Combinatorial numbers
* 計算從 n 個元素中取 k 個共有幾種組合，公式 C(n,k)=C(n−1,k−1)+C(n−1,k)
* Base Case：
    * 當 k=0 或 k=n 時，返回 1
* 遞迴步驟： 
    * C(n−1,k−1)+C(n−1,k) 

# 單元2 抽象化
## 資料抽象化
* 封裝性
    * 外部只能通過特定的方法來訪問數據，保護數據不被外部直接訪問
    * 減少程式的耦合性，並提高程式的安全性
* Abstract Data Type 
    * 讓使用者知道如何使用數據和操作，而不必了解內部的實現
* 高內聚&低耦合
    * 高內聚：模組只做特定某些工作
    * 低耦合：模組間的依賴少，修改時不易影響到其他模組

## Inheritance ( base class / superclass )
* 代碼重用：子類可以使用父類中已經定義的屬性和方法，減少重複代碼
* 擴展性：子類可以在不改變父類的情況下添加新的屬性和方法

* public：子類可以訪問父類的公共成員。
* protected：子類可以訪問父類的保護成員，但外部類無法訪問。
* private：子類無法訪問父類的私有成員。

## Overloading
* 定義多個同名但參數不同的函數
```
class Math {
public:
    // 重載的函數，處理兩個整數
    int add(int a, int b) {
        return a + b;
    }
    
    // 重載的函數，處理兩個浮點數
    double add(double a, double b) {
        return a + b;
    }
    
    // 重載的函數，處理三個整數
    int add(int a, int b, int c) {
        return a + b + c;
    }
};
```

## Overriding
* 讓子類能夠定義自己的行為，取代父類的功能
* 父類中的函數必須聲明為虛擬函數（virtual）
```
class Animal {
public:
    virtual void speak() { // 虛擬函數
        cout << "Animal speaks." << endl;
    }
};

// 定義子類
class Dog : public Animal {
public:
    void speak() override { // 覆蓋父類的虛擬函數
        cout << "Dog barks." << endl;
    }
};
```

## Exception
* 用來處理程式執行過程中，可能發生的錯誤或異常情況的機制

```
try {
        A(true); 
    } 
    
catch (const runtime_error& e) { // A 異常
        cout << "Caught an exception: " << endl; // 處理異常
    }

```

# 單元3 鏈結串列
## Pointer
* 允許直接操作記憶體，使程式能夠進行靈活的數據處理
* memory leak : 分配的記憶體未被釋放，導致無法再被使用
* delete p ; // 歸還房子

```
int var = 10;               
int* ptr = &var;           // 定義一個指向整數的指標，並初始化為 var 的地址

cout << "變量的值: " << var << endl;             // 輸出: 10
cout << "變量的地址: " << &var << endl;          // 輸出: var的地址
cout << "指標的值: " << ptr << endl;            // 輸出: 指向 var 的地址
cout << "指標所指向的值: " << *ptr << endl;      // 輸出: 10 
```

## Dynamic Array
* 在執行時動態調整大小，適應不同的需求
* 根據實際需要分配記憶體，避免浪費
* delete [] oldArray ; // 歸還舊社區

## Linked List
* 由節點（Node）組成，每個節點包含兩個主要部分：
    * Data：存儲數據，可以是任何數據類型
    * Pointer：指向下一個節點的指標，用於鏈接整個串列
```
struct Node {
    int data;         // 數據部分
    Node* next;      // 指向下一個節點的指標
};
```

* 單向鏈結串列（Singly Linked List）：
    * 每個節點只有一個指向下一個節點的指標
    * 節點的遍歷只能從頭到尾進行

* 雙向鏈結串列（Doubly Linked List）：
    * 每個節點有兩個指標：一個指向下一個節點，另一個指向前一個節點
    * 節點的遍歷可以雙向進行，方便插入和刪除操作

* 循環鏈結串列（Circular Linked List）：
    * 最後一個節點的指標指向頭節點，形成一個環
    * 可以是單向或雙向的

# 單元4 以遞迴解題

## Grammars
```
<identifier> = <leter> |
                <identifier><leter> |
                <identifier><digit>
```
* leter 終止條件
    
## Algebraic Expressions
* 前序、中序和後序是樹遍歷（Traversal）的方法，用來訪問樹中的所有節點，有不同的順序

* 前序 Prefix   運算子 運算元 運算元
* 中序 Infix    運算元 運算子 運算元
* 後序 Postfix  運算元 運算元 運算子

## Eight Queens Problem
* 在 8x8 的棋盤上放置八個皇后，使它們彼此之間不會互相攻擊
* 沒有兩個皇后可以位於同一行、同一列或同一對角線上
    
## 學習心得

線上課程:
    我覺得 DS 是線上課程真的很棒，可以重複看不熟悉的影片，期中考前也能用來複習。
    課程影片有好多好多會有看不完的感覺，不過影片內容真的很扎實!!

製作筆記:
    一開始是跟著老師的課程，用HackMD上甚麼內容就做甚麼筆記，
    其中包括了老師講的內容、程式邏輯、程式練習等等等，
    但後來發現這樣實在是花太多時間了，筆記內容變得很多，內容也做的不是很好
    所以決定只寫重點和關鍵字，讓筆記變得更精簡，
    複習的時候也能考驗一下自己有沒有記得細節。

最喜歡的章節:
    我最喜歡的章節是 [單元2 抽象化]，
    在這個單元裡，我學習到了如何控制資料的存取，
    讓使用者只能透過某些管道來取得或是更改資料，以及保護資料的方式，
    其中老師有提到"高內聚&低耦合"，這是我第一次聽到這個名詞，
    "高內聚&低耦合"可以讓程式更清楚且在修改模組時其他模組不會受到影響，
    經過了這單元學習，讓我更加了解了資料抽象化的重要性，
    以及未來要如何將其應用在自己的程式中。
