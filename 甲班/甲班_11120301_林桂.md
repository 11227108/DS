## 11120301 林桂


## 堆疊（Stack）
是一種線性資料結構，遵守「後進先出（LIFO, Last In, First Out）」的原則。表示最新加入堆疊的元素，會是最先被移除的元素。

堆疊的主要操作：
 - push：將元素加入堆疊的頂部。
 - pop：移除並返回堆疊頂部的元素。
 - getTop：取得堆疊頂部的元素，但不移除它。
 - isEmpty：檢查堆疊是否為空。

## 堆疊的應用範圍
堆疊有廣泛的應用，尤其在處理需要「回退」或「反向」操作的場景中：

1. 函數呼叫堆疊
- 應用： 函數的呼叫會使用堆疊來追蹤執行過程，當函數完成時，從堆疊中移除並返回到呼叫它的地方。
- 例子： 遞迴函數的實現。
2. 表達式的計算
- 應用： 中序（Infix）、前序（Prefix）、後序（Postfix）表達式的轉換與運算。
- 例子： 計算 (1 + 2) * (3 + 4) 的後序表示式 1 2 + 3 4 + *。
3. 括號匹配
- 應用： 驗證括號是否成對，例如 ([]{}) 是有效的，而 ([)] 是無效的。
- 方法： 使用堆疊將左括號存起來，遇到右括號時檢查是否匹配。
4. 反轉字串或數據
- 應用： 將一個字串反轉。例如，輸入 abcd，輸出 dcba。
- 方法： 將字元依序 Push 進堆疊，然後逐一 Pop 出。

```=cpp
// 括號匹配
#include <iostream>
#include <stack>
#include <string>

bool isValidParentheses(const std::string& s) {
  std::stack<char> stk;
  for (char ch : s) {
    if (ch == '(' || ch == '[' || ch == '{') {
      stk.push(ch);
    } else {
      if (stk.empty()) return false;
      char top = stk.top();
      if ((ch == ')' && top != '(') ||
          (ch == ']' && top != '[') ||
          (ch == '}' && top != '{')) {
        return false;
      }
      stk.pop();
    }
  }
  return stk.empty();
}

int main() {
  std::string test = "([]{})";
  if (isValidParentheses(test)) {
    std::cout << "Valid parentheses!" << std::endl;
  } else {
    std::cout << "Invalid parentheses!" << std::endl;
  }
  return 0;
}
```

## 堆疊應用：中序轉後序與前序、後序與前序計算

### **1. 中序轉後序**

### **轉換規則**
1. **運算元（Operands）：** 遇到運算元（如 A、B、C），直接加入結果中。
2. **左括號（`(`）：** 遇到左括號時，直接推入堆疊。
3. **右括號（`)`）：**
   - 從堆疊彈出運算子並加入結果中，直到遇到左括號。
   - 移除左括號（但不加入結果）。
4. **運算子（Operators）：**
   - 若堆疊為空或堆疊頂部為左括號，則直接推入堆疊。
   - 否則，根據運算子的優先級：
     - 若當前運算子優先級 <= 堆疊頂部運算子，將堆疊頂部的運算子彈出並加入結果。
     - 將當前運算子推入堆疊。
5. **最後處理堆疊：**
   - 將剩餘堆疊中的運算子依序彈出，加入結果中。

### **範例：中序轉後序**

#### **輸入中序**
`A + B * C`

#### **步驟**
1. `A` 是運算元，加入結果：`A`
2. `+` 是運算子，堆疊為空，推入堆疊：`+`
3. `B` 是運算元，加入結果：`A B`
4. `*` 是運算子，優先級高於 `+`，推入堆疊：`+ *`
5. `C` 是運算元，加入結果：`A B C`
6. 將堆疊運算子依序彈出：`A B C * +`

#### **輸出後序**
`A B C * +`

## **2. 中序轉前序**

### **目標**
將中序表達式（Infix，例如 `A + B * C`）轉換為前序表達式（Prefix，例如 `+ A * B C`）。

### **轉換規則**
1. **反轉中序表達式：**
   - 將表達式的順序反轉。
   - 左括號（`(`）和右括號（`)`）互換。
2. **按照中序轉後序的邏輯處理反轉的表達式，得到反轉的後序結果。**
3. **再次反轉後序結果，得到前序表達式。**

### **範例：中序轉前序**

#### **輸入中序**
`A + B * C`

#### **步驟**
1. 反轉表達式：`C * B + A`
2. 互換括號（此例中無括號）。
3. 按中序轉後序邏輯：
   - `C` 是運算元，加入結果：`C`
   - `*` 是運算子，堆疊為空，推入堆疊：`*`
   - `B` 是運算元，加入結果：`C B`
   - `+` 是運算子，優先級低於 `*`，彈出 `*` 並加入結果：`C B *`，推入 `+`：`+`
   - `A` 是運算元，加入結果：`C B * A`
4. 彈出堆疊中的運算子：`C B * A +`
5. 反轉結果：`+ A * B C`

#### **輸出前序**
`+ A * B C`


## **3. 計算後序表達式**

### **後序表達式特性**
- 運算子出現在運算元的後面。
- 適合使用堆疊處理，因為每遇到一個運算子，都能確定該運算子的兩個運算元。

### **計算步驟**
1. **初始化：** 建立一個空堆疊。
2. **逐個讀取後序表達式：**
   - 如果是運算元，推入堆疊。
   - 如果是運算子，從堆疊彈出兩個運算元：
     - 第二個彈出的是左運算元，第一個是右運算元。
     - 執行運算後，將結果推回堆疊。
3. **結束：** 當表達式處理完成時，堆疊的頂部就是結果。

### **範例：後序計算**

#### **後序**
`3 4 2 * +`

#### **步驟**
1. 初始化：空堆疊。
2. `3` 是運算元，推入堆疊：`[3]`
3. `4` 是運算元，推入堆疊：`[3, 4]`
4. `2` 是運算元，推入堆疊：`[3, 4, 2]`
5. `*` 是運算子，彈出 `2` 和 `4`，計算 `4 * 2 = 8`，結果推入堆疊：`[3, 8]`
6. `+` 是運算子，彈出 `8` 和 `3`，計算 `3 + 8 = 11`，結果推入堆疊：`[11]`

#### **結果**
`11`


## **4. 計算前序表達式**

### **前序表達式特性**
- 運算子出現在運算元的前面。
- 適合使用堆疊處理，從右至左掃描表達式。

### **計算步驟**
1. **初始化：** 建立一個空堆疊。
2. **從右至左讀取前序表達式：**
   - 如果是運算元，推入堆疊。
   - 如果是運算子，從堆疊彈出兩個運算元：
     - 第一個彈出的是右運算元，第二個是左運算元。
     - 執行運算後，將結果推回堆疊。
3. **結束：** 當表達式處理完成時，堆疊的頂部就是結果。

### **範例：前序計算**

#### **前序**
`+ 3 * 4 2`

#### **步驟**
1. 初始化：空堆疊。
2. 從右至左掃描：
   - `2` 是運算元，推入堆疊：`[2]`
   - `4` 是運算元，推入堆疊：`[2, 4]`
   - `*` 是運算子，彈出 `4` 和 `2`，計算 `4 * 2 = 8`，結果推入堆疊：`[8]`
   - `3` 是運算元，推入堆疊：`[8, 3]`
   - `+` 是運算子，彈出 `3` 和 `8`，計算 `3 + 8 = 11`，結果推入堆疊：`[11]`

#### **結果**
`11`

- **中序轉後序：** 使用堆疊處理括號與運算子的優先級。
- **中序轉前序：** 先反轉表達式，再按後序邏輯處理，最後反轉結果。
- **後序計算：** 運算元推入堆疊，運算子處理堆疊頂部兩個運算元。
- **前序計算：** 從右至左處理，運算元推入堆疊，運算子處理頂部兩個運算元。

## 佇列（Queue）

**Queue（佇列）** 是一種線性資料結構，遵守「**先進先出（FIFO, First In First Out）**」的原則。 
這表示最早加入佇列的元素，會是最先被移除的元素。

### **基本操作**
1. **Create an Empty Queue (建構空佇列)**：初始化一個空佇列，準備進行後續操作。
2. **Destroy a Queue (解構佇列)**：釋放佇列所占用的資源，避免內存洩漏。
3. **Enqueue（入列）：** 在佇列尾端新增一個元素。
4. **Dequeue（出列）：** 從佇列前端移除並返回一個元素。
5. **getFront：** 取得佇列前端的元素，但不移除它。
6. **isEmpty：** 檢查佇列是否為空。
7. **isFull（對於固定大小的佇列）：** 檢查佇列是否已滿。


## **2. Queue 的應用**

Queue 在多種場景中都有廣泛應用，尤其是需要順序處理的情況。

### **任務排程**
- **應用：** 作業系統中的 CPU 任務排程，將進程排入等待執行的佇列。
- **方法：** 使用 Queue 按照到達的順序安排執行。


### **資料緩存**
- **應用：** 環形緩衝區（Circular Buffer）處理固定大小的緩衝隊列。
- **方法：** 使用固定大小的 Queue。

### **判斷迴文**
- **應用：** 使用 Queue 判斷一個字串是否為迴文（Palindrome），即正序和反序讀取相同的字串。
- **方法：**
  1. 將字串的每個字符加入 Queue（正序儲存）。
  2. 同時使用 Stack 儲存字串的反序。
  3. 比較 Queue 和 Stack 中的字符：
     - 每次從 Queue 前端和 Stack 頂部取出一個字符，若所有字符均相同，則該字串為迴文。
  4. 若發現任一字符不匹配，則該字串不是迴文。


## Queue 的三種實現方式


## **1. 使用指標完成的 Queue**

### **特性**
- **結構：** 使用鏈結串列，每個節點包含數據和指向下一個節點的指標。
- **操作：**
  - `front` 指向第一個節點。
  - `rear` 指向最後一個節點。
  - 新增和移除操作只需更新指標。
- **優點：** 無固定大小限制，動態分配內存。

![image](https://hackmd.io/_uploads/HyXQAgz4Jx.png)

## **2. 使用環狀指標完成的 Queue**

### **特性**
- **結構：** 環狀鏈結串列，只使用一個指標 `backptr`。
  - `backptr` 指向隊列最後一個節點。
  - `front` 由 `backptr->next` 獲得。
- **操作：**
  - 新增元素：新增節點並更新 `backptr` 指向新的最後節點。
  - 移除元素：移除 `backptr->next`，即第一個節點。
  - 空隊列判斷：`backptr == nullptr`。
- **優點：** 僅需一個指標儲存。

![image](https://hackmd.io/_uploads/S1igRxz41e.png)

## **3. 使用陣列完成的 Queue**

### **特性**
- **結構：** 使用一維陣列，並追蹤 `front` 和 `rear` 的索引。
- **操作：**
  - 新增元素：將新元素插入 `rear` 所指向的位置，然後更新索引。
  - 移除元素：更新 `front` 索引。
  - 滿隊列判斷：`(rear + 1) % SIZE == front`。
- **優點：** 實現簡單，操作高效。
- **缺點：** 陣列大小固定，需設置最大容量。


## Big O Notation

**Big O Notation** 是一種用於表示演算法效率的數學符號，描述演算法的執行時間或空間需求如何隨輸入數據規模增長而變化。

- **標準化分析：** 提供一個通用的方式來比較不同演算法的效率。
- **忽略常數：** 只專注於輸入數量的增長趨勢，而非具體的執行細節。
- **衡量最壞情況：** 通常用來表示最壞情況下的執行時間或資源使用。


## **常見的 Big O**

| 表達式        | 名稱                     | 描述                                                                 |
| -------------- | ------------------------ | -------------------------------------------------------------------- |
| **O($1$)**       | 常數時間                 | 不受輸入大小影響，執行時間固定，例如數組訪問 `arr[i]`。               |
| **O($\log n$)**   | 對數時間                 | 每次操作都將問題規模減小一半，例如二分搜尋法。                       |
| **O($n$)**       | 線性時間                 | 執行時間與輸入大小成正比，例如遍歷數組。                             |
| **O($n \log n$)** | 線性對數時間             | 常見於高效排序演算法，例如快速排序和合併排序。                       |
| **O($n^{2}$)**      | 平方時間                 | 常見於雙重迴圈，例如暴力解法的排序或矩陣乘法。                       |
| **O($2^{n}$)**      | 指數時間                 | 演算法的執行時間隨輸入呈指數增長，例如暴力解決排列組合問題。         |
| **O($n!$)**      | 階乘時間                 | 常見於計算所有排列的情況，例如旅行推銷員問題（TSP）。                |


![bigO](https://hackmd.io/_uploads/SJz2X5MEJl.png)


# 簡單的排序演算法：氣泡排序、插入排序、選擇排序

## **1. 氣泡排序（Bubble Sort）**

- **邏輯：** 從數列的左側開始，反覆比較相鄰的兩個元素，若順序不對則交換，將最大（或最小）的元素「冒泡」到數列的一端。
- **步驟：**
  1. 比較數列中每一對相鄰元素，若順序不對則交換。
  2. 重複此過程 \( n-1 \) 次，每次將未排序部分的最大元素移到正確位置。

    ```=cpp
    void bubbleSort(std::vector<int>& arr) {
      int n = arr.size();
      for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
          if (arr[j] > arr[j + 1]) {
            std::swap(arr[j], arr[j + 1]); // 交換相鄰元素
          }
        }
      }
    }
    ```

### **Big O Notation**
| 時間複雜度 | 描述               |
| ----------- | ------------------ |
| 最佳情況    | \( O(n) \)：數列已排序時，只需進行一次比較即可。 |
| 最壞情況    | \( O($n^{2}$) \)：數列完全逆序時，每次都需比較並交換。 |
| 平均情況    | \( O($n^{2}$) \)：需要進行多次交換與比較。         |

- **空間複雜度：** \( O(1) \)（原地排序）。

### **穩定性**
- **是否穩定：** 是。
- **原因：** 相等的元素不會被交換，保持相對順序不變。

## **2. 插入排序（Insertion Sort）**

- **邏輯：** 將數列分為已排序與未排序兩部分，逐一從未排序部分取出元素，插入到已排序部分的適當位置。
- **步驟：**
  1. 將第一個元素視為已排序。
  2. 從第二個元素開始，將其插入到已排序部分的正確位置。
  3. 重複此過程直到所有元素排序完成。
    ```=cpp
    void insertionSort(std::vector<int>& arr) {
      int n = arr.size();
      for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) { // 移動大於 key 的元素
          arr[j + 1] = arr[j];
          j--;
        }
        arr[j + 1] = key; // 插入 key 到正確位置
      }
    }
    ```
### **Big O Notation**
| 時間複雜度 | 描述               |
| ----------- | ------------------ |
| 最佳情況    | \( O(n) \)：數列已排序時，只需進行比較。 |
| 最壞情況    | \( O($n^{2}$) \)：數列完全逆序時，每次都需移動元素。 |
| 平均情況    | \( O($n^{2}$) \)：需移動元素到適當位置。    |

- **空間複雜度：** \( O(1) \)（原地排序）。

### **穩定性**
- **是否穩定：** 是。
- **原因：** 插入時不會改變相等元素的相對順序。


## **3. 選擇排序（Selection Sort）**

- **邏輯：** 將數列分為已排序與未排序兩部分，從未排序部分選擇最小（或最大）元素，並將其放到已排序部分的末尾。
- **步驟：**
  1. 找到數列中最小的元素，將其與第一個元素交換。
  2. 從剩餘未排序部分中找到最小元素，與未排序部分的第一個元素交換。
  3. 重複此過程直到所有元素排序完成。

    ```=cpp
    void selectionSort(std::vector<int>& arr) {
      int n = arr.size();
      for (int i = 0; i < n - 1; i++) {
        int minIndex = i; // 假設當前位置是最小值
        for (int j = i + 1; j < n; j++) {
          if (arr[j] < arr[minIndex]) {
            minIndex = j; // 更新最小值的位置
          }
        }
        std::swap(arr[i], arr[minIndex]); // 將最小值放到正確位置
      }
    }
    ```

### **Big O Notation**
| 時間複雜度 | 描述               |
| ----------- | ------------------ |
| 最佳情況    | \( O($n^{2}$) \)：無論初始排序如何，都需進行 \( n-1 \) 次比較。 |
| 最壞情況    | \( O($n^{2}$) \)：與最佳情況相同，皆需比較 \( n-1 \) 次。     |
| 平均情況    | \( O($n^{2}$) \)：需要進行多次比較與交換。                 |

- **空間複雜度：** \( O(1) \)（原地排序）。

### **穩定性**
- **是否穩定：** 否。
- **原因：** 當交換元素時，可能會改變相等元素的相對順序。

## **4. 希爾排序（Shell Sort）**

- **邏輯：** 是插入排序的一種優化版本，通過引入 **gap（間隔）** 的概念來分組排序，逐步減小間隔，最終使整個數列有序。
- **步驟：**
  1. 選擇初始 gap（例如，數列長度的一半）。
  2. 將數列分為多組，對每組使用插入排序。
  3. 將 gap 不斷減半，直到 gap 為 1，最後一次執行標準的插入排序。
### **關於 Shell 排序的優勢**
- Shell 排序通過 gap 分組，減少了插入排序中元素的移動次數，對於中型和大型數列有良好的性能。
- 適用於數列長度較大、內存有限的情境。
    ```=cpp
    void shellSort(std::vector<int>& arr) {
      int n = arr.size();
      for (int gap = n / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < n; i++) {
          int temp = arr[i];
          int j;
          for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
            arr[j] = arr[j - gap]; // 移動元素
          }
          arr[j] = temp; // 插入元素
        }
      }
    }
    ```

### **Big O Notation**
| 時間複雜度 | 描述               |
| ----------- | ------------------ |
| 最佳情況    | \( O($n \log n$) \)：當使用適當的 gap 序列時，例如 Hibbard 或 Knuth 序列。 |
| 最壞情況    | \( O($n^{2}$) \)：當 gap 選擇不佳時，表現與插入排序類似。 |
| 平均情況    | \( O($n^{1.5}$) \)：通常情況下優於插入排序和氣泡排序。 |

- **空間複雜度：** \( O(1) \)（原地排序）。

### **穩定性**
- **是否穩定：** 否。
- **原因：** 不同 gap 步驟中的交換操作可能改變相等元素的相對順序。

---

| 排序法       | 時間複雜度（最壞） | 空間複雜度 | 穩定性   | 適用場景                       |
| ------------ | ------------------ | ---------- | -------- | ------------------------------ |
| 氣泡排序     | \( O($n^{2}$) \)       | \( O(1) \) | 是       | 初學者學習、數列規模較小時。   |
| 插入排序     | \( O($n^{2}$) \)       | \( O(1) \) | 是       | 數列部分有序、數列規模較小時。 |
| 選擇排序     | \( O($n^{2}$) \)       | \( O(1) \) | 否       | 數列規模小且不關注穩定性時。   |
| Shell 排序   | \( O($n \log n$) \)  | \( O(1) \) | 否       | 大型數列排序，對效率有更高需求時。 |


# 較快的排序演算法：合併排序、快速排序、基數排序


## **1. 合併排序（Merge Sort）**

- **邏輯：** 是一種 **分治法（Divide and Conquer）** 演算法：
  1. 將數列遞迴地分成兩部分，直到每部分只剩一個元素。
  2. 將分割後的數列合併，並在合併過程中進行排序。
- **特性：** 即使在最壞情況下，依然能保證 \( O(n logn) \) 的穩定性能。

```cpp
void merge(std::vector<int>& arr, int left, int mid, int right) {
  int n1 = mid - left + 1, n2 = right - mid;
  std::vector<int> L(n1), R(n2);

  for (int i = 0; i < n1; i++) L[i] = arr[left + i];
  for (int i = 0; i < n2; i++) R[i] = arr[mid + 1 + i];

  int i = 0, j = 0, k = left;
  while (i < n1 && j < n2) {
    if (L[i] <= R[j]) arr[k++] = L[i++];
    else arr[k++] = R[j++];
  }
  while (i < n1) arr[k++] = L[i++];
  while (j < n2) arr[k++] = R[j++];
}

void mergeSort(std::vector<int>& arr, int left, int right) {
  if (left >= right) return;
  int mid = left + (right - left) / 2;
  mergeSort(arr, left, mid);
  mergeSort(arr, mid + 1, right);
  merge(arr, left, mid, right);
}
```

### **Big O Notation**
| 時間複雜度 | 描述               |
| ----------- | ------------------ |
| 最佳情況    | ( O($n \log n$) )：分割與合併的操作是線性對數級別。 |
| 最壞情況    | ( O($n \log n$) )：與最佳情況相同，因為無論如何都需完全分割與合併。 |
| 平均情況    | ( O($n \log n$) )：每次分割與合併的複雜度是對數級別。 |

- **空間複雜度：** ( O(n) )，需要額外的空間來存儲分割後的子數列。

### **穩定性**
- **是否穩定：** 是。
- **原因：** 合併時，相等的元素不會改變相對順序。


## **2. 快速排序（Quick Sort）**

### **演算法描述**
- **邏輯：** 是一種 **分治法（Divide and Conquer）** 演算法：
  1. 選擇一個基準（Pivot）。
  2. 將數列分為兩部分，左邊小於等於基準，右邊大於基準。
  3. 對左右部分遞迴執行相同操作。
- **特性：** 快速排序在大部分情況下比合併排序快，但最壞情況下的性能較差。


```cpp
int partition(std::vector<int>& arr, int low, int high) {
  int pivot = arr[high]; // 選擇最後一個元素為基準
  int i = low - 1;

  for (int j = low; j < high; j++) {
    if (arr[j] <= pivot) {
      std::swap(arr[++i], arr[j]);
    }
  }
  std::swap(arr[i + 1], arr[high]);
  return i + 1;
}

void quickSort(std::vector<int>& arr, int low, int high) {
  if (low < high) {
    int pi = partition(arr, low, high);
    quickSort(arr, low, pi - 1);
    quickSort(arr, pi + 1, high);
  }
}
```

### **Big O Notation**
| 時間複雜度 | 描述               |
| ----------- | ------------------ |
| 最佳情況    | ( O($n \log n$) )：每次選擇的基準將數列平分。 |
| 最壞情況    | ( O( $n^{2}$ ) )：基準選擇不佳時，可能每次只分出一個元素。 |
| 平均情況    | ( O($n \log n$) )：大部分情況下分割相對平衡。 |

- **空間複雜度：** \( O(logn) \)（遞迴棧空間）。

### **穩定性**
- **是否穩定：** 否。
- **原因：** 分割時交換元素可能改變相等元素的相對順序。


## **3. 基數排序（Radix Sort）**


- **邏輯：** 是一種 **非比較排序演算法**，依次按照數字的各位（從最低位到最高位）進行排序。
  1. 根據當前位數的數值，將數列分配到桶（Bucket）中。
  2. 按桶的順序重新排列數列。
  3. 重複過程直到處理完所有位數。


```cpp
void countingSortForRadix(std::vector<int>& arr, int exp) {
  int n = arr.size();
  std::vector<int> output(n);
  int count[10] = {0};

  for (int i = 0; i < n; i++) count[(arr[i] / exp) % 10]++;
  for (int i = 1; i < 10; i++) count[i] += count[i - 1];
  for (int i = n - 1; i >= 0; i--) {
    output[count[(arr[i] / exp) % 10] - 1] = arr[i];
    count[(arr[i] / exp) % 10]--;
  }
  for (int i = 0; i < n; i++) arr[i] = output[i];
}

void radixSort(std::vector<int>& arr) {
  int maxVal = *std::max_element(arr.begin(), arr.end());
  for (int exp = 1; maxVal / exp > 0; exp *= 10) {
    countingSortForRadix(arr, exp);
  }
}
```

### **Big O Notation**
| 時間複雜度 | 描述               |
| ----------- | ------------------ |
| 最佳情況    | \( O($n \cdot k$) \)：k 是數列的最大位數。 |
| 最壞情況    | \( O($n \cdot k$) \)：位數固定時，複雜度取決於數列長度。 |
| 平均情況    | \( O($n \cdot k$) \)：對於大數據集合非常高效。 |

- **空間複雜度：** \( O(n + k) \)，需要額外的桶空間。

### **穩定性**
- **是否穩定：** 是。
- **原因：** 在每次計數排序中，相等元素的順序不會改變。

---

| 排序法       | 時間複雜度（最壞） | 空間複雜度    | 穩定性   | 適用場景                       |
| ------------ | ------------------ | ------------- | -------- | ------------------------------ |
| 合併排序     | ( O($n \log n$) )  | \( O(n) \)    | 是       | 大型數據集，穩定性要求高時。   |
| 快速排序     | \( O($n^{2}$) \)       | \( O(\log n) \) | 否      | 實際應用中非常高效的排序需求。 |
| 基數排序     | \( O($n \cdot k$) \) | \( O(n + k) \) | 是      | 對位數固定的數字或字母排序。   |



## 樹 (Tree)
樹是一種遞迴的資料結構，由 **節點 (Node)** 組成，每個節點包含：
- **值 (Value)**
- 一組指向子節點的指標 (通常稱為子樹)

### 樹的特性
1. 根節點 (Root)：樹的最上層節點。
2. 子節點 (Child)：根節點或其他節點指向的節點。
3. 父節點 (Parent)：擁有子節點的節點。
4. 葉節點 (Leaf)：沒有子節點的節點。
5. 樹的高度 (Height)：從根節點到最遠葉節點的邊數。

## 二元樹 (Binary Tree, BT)
- 每個節點最多有兩個子節點，分別為 **左子節點** 和 **右子節點**。
- 二元樹適用於許多算法，並提供基礎結構支持各種變形（如 BST）。

## 二元搜尋樹 (Binary Search Tree)
- 二元樹的一種變形，具有以下性質：
  - **左子樹節點的值 < 父節點值**。
  - **右子樹節點的值 > 父節點值**。
- 適合用於高效查詢、插入與刪除。

## 樹的分類
1. **平衡樹 (Balanced Tree)**：
   - 所有葉節點的高度差不超過 1。
   - 例子：AVL Tree, Red-Black Tree。
2. **滿樹 (Full Tree)**：
   - 每個節點要麼是葉節點，要麼有兩個子節點。
3. **完全樹 (Complete Tree)**：
   - 除最後一層外，所有層都完全填滿。
   - 最後一層的節點從左到右依次排列。

### BST ADT
```cpp
class BST {
public:
    void insert(int value); // 插入值
    void remove(int value); // 刪除值
    bool search(int value); // 查詢值是否存在
    void traverseInOrder(); // 中序走訪
    void traversePreorder(); // 前序走訪
    void traversePostorder(); // 後序走訪
};
```



## BST 操作

### 1. 查詢 (Search)
- 遞迴搜尋目標值。
  ```cpp
  bool search(Node* root, int value) {
      if (!root) return false;
      if (root->value == value) return true;
      if (value < root->value) return search(root->left, value);
      return search(root->right, value);
  }
  ```
- **Best Case**: O(1)（目標值為根節點）
- **Average Case**: O(log n)（樹是平衡的）
- **Worst Case**: O(n)（Skew Tree）

### 2. 插入 (Insert)
- 遵守 BST 性質插入新節點。
  ```cpp
  Node* insert(Node* root, int value) {
      if (!root) return new Node(value);
      if (value < root->value) {
          root->left = insert(root->left, value);
      } else {
          root->right = insert(root->right, value);
      }
      return root;
  }
  ```
- **Best Case**: O(1)（插入作為根節點）
- **Average Case**: O(log n)（樹是平衡的）
- **Worst Case**: O(n)（Skew Tree）

### 3. 刪除 (Remove)
- 分為三種情況：
  1. 節點無子節點：直接刪除。
  2. 節點有一個子節點：刪除後用子節點替代。
  3. 節點有兩個子節點：用右子樹中的最小值(或左子樹最大值)替代，然後刪除該最小值。
  ```cpp
  Node* remove(Node* root, int value) {
      if (!root) return nullptr;
      if (value < root->value) {
          root->left = remove(root->left, value);
      } else if (value > root->value) {
          root->right = remove(root->right, value);
      } else {
          if (!root->left) {
              Node* temp = root->right;
              delete root;
              return temp;
          } else if (!root->right) {
              Node* temp = root->left;
              delete root;
              return temp;
          }
          Node* temp = findMin(root->right);
          root->value = temp->value;
          root->right = remove(root->right, temp->value);
      }
      return root;
  }

  Node* findMin(Node* root) {
      while (root->left) root = root->left;
      return root;
  }
  ```
- **Best Case**: O(1)（刪除無子節點的葉節點）
- **Average Case**: O(log n)（樹是平衡的）
- **Worst Case**: O(n)（Skew Tree）

## 樹的走訪方式
1. **前序走訪 (Preorder Traversal)**：
   - 訪問節點 → 左子樹 → 右子樹
   - 適用於複製樹。
     ```cpp
     void preorderTraversal(Node* root) {
         if (!root) return;
         cout << root->value << " ";
         preorderTraversal(root->left);
         preorderTraversal(root->right);
     }
     ```

2. **中序走訪 (Inorder Traversal)**：
   - 左子樹 → 訪問節點 → 右子樹
   - 適用於輸出排序結果。
     ```cpp
     void inorderTraversal(Node* root) {
         if (!root) return;
         inorderTraversal(root->left);
         cout << root->value << " ";
         inorderTraversal(root->right);
     }
     ```

3. **後序走訪 (Postorder Traversal)**：
   - 左子樹 → 右子樹 → 訪問節點
   - 適用於刪除整棵樹。
     ```cpp
     void postorderTraversal(Node* root) {
         if (!root) return;
         postorderTraversal(root->left);
         postorderTraversal(root->right);
         cout << root->value << " ";
     }
     ```
- **前序走訪 (Preorder)**: O(n)
- **中序走訪 (Inorder)**: O(n)
- **後序走訪 (Postorder)**: O(n)

| 操作         | Best Case       | Average Case    | Worst Case     |
|--------------|-----------------|-----------------|----------------|
| **Search**   | O(1)            | O(log n)        | O(n)           |
| **Insert**   | O(1)            | O(log n)        | O(n)           |
| **Remove**   | O(1)            | O(log n)        | O(n)           |
| **Traversal**| O(n)            | O(n)            | O(n)           |

### 學習心得：
學完這幾個單元後，讓我認識到了更多實用的資料結構，像是stack、queue和tree這些我覺得都非常好用，利用這些資料結構特性可以讓我很方便的實作出我想要達到的目的，像stack就幫助我完成老鼠走迷宮的作業，因為stack很適合遇到死路時退回的操作，而queue讓我完成廚師排程的問題，根據先進先出的特性讓我可以讓每個訂單依照順序執行，而tree也幫助我完成最後一次作業，讓我可以根據寶可夢的血量建出一棵二元搜尋樹，以便後續的操作。而其中還有一個單元是在分析演算法的複雜度，這讓我了解到如何計算演算法的效率，認知到了時間複雜度和空間複雜度的重要性，在解決問題時，不僅要考慮演算法是否正確，還需要衡量其性能，特別是當資料量變大時，效率的差異可能會非常明顯，因此有一個好的演算法是非常重要的。





